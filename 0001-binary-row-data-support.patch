From 7273d276c8d36bf876777d8d35369f4ad43a6df2 Mon Sep 17 00:00:00 2001
From: "ocean.wy" <ocean.wy@alibaba-inc.com>
Date: Fri, 29 Aug 2025 15:43:42 +0800
Subject: [PATCH] binary row data support

---
 .../fluss/row/AbstractBinaryWriter.java       | 282 ++++++++++
 .../com/alibaba/fluss/row/BinaryRowData.java  | 504 ++++++++++++++++++
 .../alibaba/fluss/row/BinaryRowWriter.java    | 119 +++++
 .../com/alibaba/fluss/row/BinarySection.java  |  28 +
 .../alibaba/fluss/row/BinarySegmentUtils.java | 292 ++++++++++
 .../com/alibaba/fluss/row/BinaryWriter.java   | 120 +++++
 .../com/alibaba/fluss/row/DataSetters.java    |  68 +++
 .../alibaba/fluss/utils/MurmurHashUtils.java  |  36 ++
 .../alibaba/fluss/row/BinaryRowDataTest.java  | 477 +++++++++++++++++
 .../fluss/row/BinarySegmentUtilsTest.java     |   2 +-
 .../alibaba/fluss/row/DataFormatTestUtil.java | 185 +++++++
 .../fluss/testutils/DataTestUtils.java        |   2 +-
 12 files changed, 2113 insertions(+), 2 deletions(-)
 create mode 100644 fluss-common/src/main/java/com/alibaba/fluss/row/AbstractBinaryWriter.java
 create mode 100644 fluss-common/src/main/java/com/alibaba/fluss/row/BinaryRowData.java
 create mode 100644 fluss-common/src/main/java/com/alibaba/fluss/row/BinaryRowWriter.java
 create mode 100644 fluss-common/src/main/java/com/alibaba/fluss/row/BinaryWriter.java
 create mode 100644 fluss-common/src/main/java/com/alibaba/fluss/row/DataSetters.java
 create mode 100644 fluss-common/src/test/java/com/alibaba/fluss/row/BinaryRowDataTest.java
 create mode 100644 fluss-common/src/test/java/com/alibaba/fluss/row/DataFormatTestUtil.java

diff --git a/fluss-common/src/main/java/com/alibaba/fluss/row/AbstractBinaryWriter.java b/fluss-common/src/main/java/com/alibaba/fluss/row/AbstractBinaryWriter.java
new file mode 100644
index 00000000..84e02aea
--- /dev/null
+++ b/fluss-common/src/main/java/com/alibaba/fluss/row/AbstractBinaryWriter.java
@@ -0,0 +1,282 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.fluss.row;
+
+import com.alibaba.fluss.memory.MemorySegment;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+
+import static com.alibaba.fluss.row.BinarySection.MAX_FIX_PART_DATA_SIZE;
+
+/**
+ * Use the special format to write data to a {@link MemorySegment} (its capacity grows
+ * automatically).
+ *
+ * <p>If write a format binary: 1. New a writer. 2. Write each field by writeXX or setNullAt.
+ * (Variable length fields can not be written repeatedly.) 3. Invoke {@link #complete()}.
+ *
+ * <p>If want to reuse this writer, please invoke {@link #reset()} first.
+ */
+abstract class AbstractBinaryWriter implements BinaryWriter {
+
+    protected MemorySegment segment;
+
+    protected int cursor;
+
+    /** Set offset and size to fix len part. */
+    protected abstract void setOffsetAndSize(int pos, int offset, long size);
+
+    /** Get field offset. */
+    protected abstract int getFieldOffset(int pos);
+
+    /** After grow, need point to new memory. */
+    protected abstract void afterGrow();
+
+    protected abstract void setNullBit(int ordinal);
+
+    /** See {@link BinarySegmentUtils#readBinaryString(MemorySegment[], int, int, long)}. */
+    @Override
+    public void writeString(int pos, BinaryString input) {
+        if (input.getSegments() == null) {
+            String javaObject = input.toString();
+            writeBytes(pos, javaObject.getBytes(StandardCharsets.UTF_8));
+        } else {
+            int len = input.getSizeInBytes();
+            if (len <= 7) {
+                byte[] bytes = BinarySegmentUtils.allocateReuseBytes(len);
+                BinarySegmentUtils.copyToBytes(
+                        input.getSegments(), input.getOffset(), bytes, 0, len);
+                writeBytesToFixLenPart(segment, getFieldOffset(pos), bytes, len);
+            } else {
+                writeSegmentsToVarLenPart(pos, input.getSegments(), input.getOffset(), len);
+            }
+        }
+    }
+
+    private void writeBytes(int pos, byte[] bytes) {
+        int len = bytes.length;
+        if (len <= MAX_FIX_PART_DATA_SIZE) {
+            writeBytesToFixLenPart(segment, getFieldOffset(pos), bytes, len);
+        } else {
+            writeBytesToVarLenPart(pos, bytes, len);
+        }
+    }
+
+    @Override
+    public void writeBinary(int pos, byte[] bytes) {
+        int len = bytes.length;
+        if (len <= MAX_FIX_PART_DATA_SIZE) {
+            writeBytesToFixLenPart(segment, getFieldOffset(pos), bytes, len);
+        } else {
+            writeBytesToVarLenPart(pos, bytes, len);
+        }
+    }
+
+    @Override
+    public void writeDecimal(int pos, Decimal value, int precision) {
+        assert value == null || (value.precision() == precision);
+
+        if (Decimal.isCompact(precision)) {
+            assert value != null;
+            writeLong(pos, value.toUnscaledLong());
+        } else {
+            // grow the global buffer before writing data.
+            ensureCapacity(16);
+
+            // zero-out the bytes
+            segment.putLong(cursor, 0L);
+            segment.putLong(cursor + 8, 0L);
+
+            // Make sure Decimal object has the same scale as DecimalType.
+            // Note that we may pass in null Decimal object to set null for it.
+            if (value == null) {
+                setNullBit(pos);
+                // keep the offset for future update
+                setOffsetAndSize(pos, cursor, 0);
+            } else {
+                final byte[] bytes = value.toUnscaledBytes();
+                assert bytes.length <= 16;
+
+                // Write the bytes to the variable length portion.
+                segment.put(cursor, bytes, 0, bytes.length);
+                setOffsetAndSize(pos, cursor, bytes.length);
+            }
+
+            // move the cursor forward.
+            cursor += 16;
+        }
+    }
+
+    @Override
+    public void writeTimestampLtz(int pos, TimestampLtz value, int precision) {
+        if (TimestampLtz.isCompact(precision)) {
+            writeLong(pos, value.getEpochMillisecond());
+        } else {
+            // store the nanoOfMillisecond in fixed-length part as offset and nanoOfMillisecond
+            ensureCapacity(8);
+
+            if (value == null) {
+                setNullBit(pos);
+                // zero-out the bytes
+                segment.putLong(cursor, 0L);
+                setOffsetAndSize(pos, cursor, 0);
+            } else {
+                segment.putLong(cursor, value.getEpochMillisecond());
+                setOffsetAndSize(pos, cursor, value.getNanoOfMillisecond());
+            }
+
+            cursor += 8;
+        }
+    }
+
+    @Override
+    public void writeTimestampNtz(int pos, TimestampNtz value, int precision) {
+        if (TimestampNtz.isCompact(precision)) {
+            writeLong(pos, value.getMillisecond());
+        } else {
+            // store the nanoOfMillisecond in fixed-length part as offset and nanoOfMillisecond
+            ensureCapacity(8);
+
+            if (value == null) {
+                setNullBit(pos);
+                // zero-out the bytes
+                segment.putLong(cursor, 0L);
+                setOffsetAndSize(pos, cursor, 0);
+            } else {
+                segment.putLong(cursor, value.getMillisecond());
+                setOffsetAndSize(pos, cursor, value.getNanoOfMillisecond());
+            }
+
+            cursor += 8;
+        }
+    }
+
+    protected void zeroOutPaddingBytes(int numBytes) {
+        if ((numBytes & 0x07) > 0) {
+            segment.putLong(cursor + ((numBytes >> 3) << 3), 0L);
+        }
+    }
+
+    protected void ensureCapacity(int neededSize) {
+        final int length = cursor + neededSize;
+        if (segment.size() < length) {
+            grow(length);
+        }
+    }
+
+    private void writeSegmentsToVarLenPart(
+            int pos, MemorySegment[] segments, int offset, int size) {
+        final int roundedSize = roundNumberOfBytesToNearestWord(size);
+
+        // grow the global buffer before writing data.
+        ensureCapacity(roundedSize);
+
+        zeroOutPaddingBytes(size);
+
+        if (segments.length == 1) {
+            segments[0].copyTo(offset, segment, cursor, size);
+        } else {
+            writeMultiSegmentsToVarLenPart(segments, offset, size);
+        }
+
+        setOffsetAndSize(pos, cursor, size);
+
+        // move the cursor forward.
+        cursor += roundedSize;
+    }
+
+    private void writeMultiSegmentsToVarLenPart(MemorySegment[] segments, int offset, int size) {
+        // Write the bytes to the variable length portion.
+        int needCopy = size;
+        int fromOffset = offset;
+        int toOffset = cursor;
+        for (MemorySegment sourceSegment : segments) {
+            int remain = sourceSegment.size() - fromOffset;
+            if (remain > 0) {
+                int copySize = Math.min(remain, needCopy);
+                sourceSegment.copyTo(fromOffset, segment, toOffset, copySize);
+                needCopy -= copySize;
+                toOffset += copySize;
+                fromOffset = 0;
+            } else {
+                fromOffset -= sourceSegment.size();
+            }
+        }
+    }
+
+    private void writeBytesToVarLenPart(int pos, byte[] bytes, int len) {
+        final int roundedSize = roundNumberOfBytesToNearestWord(len);
+
+        // grow the global buffer before writing data.
+        ensureCapacity(roundedSize);
+
+        zeroOutPaddingBytes(len);
+
+        // Write the bytes to the variable length portion.
+        segment.put(cursor, bytes, 0, len);
+
+        setOffsetAndSize(pos, cursor, len);
+
+        // move the cursor forward.
+        cursor += roundedSize;
+    }
+
+    /** Increases the capacity to ensure that it can hold at least the minimum capacity argument. */
+    private void grow(int minCapacity) {
+        int oldCapacity = segment.size();
+        int newCapacity = oldCapacity + (oldCapacity >> 1);
+        if (newCapacity - minCapacity < 0) {
+            newCapacity = minCapacity;
+        }
+        segment = MemorySegment.wrap(Arrays.copyOf(segment.getArray(), newCapacity));
+        afterGrow();
+    }
+
+    protected static int roundNumberOfBytesToNearestWord(int numBytes) {
+        int remainder = numBytes & 0x07;
+        if (remainder == 0) {
+            return numBytes;
+        } else {
+            return numBytes + (8 - remainder);
+        }
+    }
+
+    private static void writeBytesToFixLenPart(
+            MemorySegment segment, int fieldOffset, byte[] bytes, int len) {
+        long firstByte = len | 0x80; // first bit is 1, other bits is len
+        long sevenBytes = 0L; // real data
+        if (BinaryRowData.LITTLE_ENDIAN) {
+            for (int i = 0; i < len; i++) {
+                sevenBytes |= ((0x00000000000000FFL & bytes[i]) << (i * 8L));
+            }
+        } else {
+            for (int i = 0; i < len; i++) {
+                sevenBytes |= ((0x00000000000000FFL & bytes[i]) << ((6 - i) * 8L));
+            }
+        }
+
+        final long offsetAndSize = (firstByte << 56) | sevenBytes;
+
+        segment.putLong(fieldOffset, offsetAndSize);
+    }
+
+    public MemorySegment getSegments() {
+        return segment;
+    }
+}
diff --git a/fluss-common/src/main/java/com/alibaba/fluss/row/BinaryRowData.java b/fluss-common/src/main/java/com/alibaba/fluss/row/BinaryRowData.java
new file mode 100644
index 00000000..59579de6
--- /dev/null
+++ b/fluss-common/src/main/java/com/alibaba/fluss/row/BinaryRowData.java
@@ -0,0 +1,504 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.fluss.row;
+
+import com.alibaba.fluss.annotation.Internal;
+import com.alibaba.fluss.memory.MemorySegment;
+import com.alibaba.fluss.types.DataType;
+import com.alibaba.fluss.types.DecimalType;
+import com.alibaba.fluss.types.LocalZonedTimestampType;
+import com.alibaba.fluss.types.TimestampType;
+
+import javax.annotation.Nullable;
+
+import java.nio.ByteOrder;
+
+import static com.alibaba.fluss.utils.Preconditions.checkArgument;
+
+/**
+ * An implementation of {@link InternalRow} which is backed by {@link MemorySegment} instead of
+ * Object. It can significantly reduce the serialization/deserialization of Java objects.
+ *
+ * <p>A Row has two part: Fixed-length part and variable-length part.
+ *
+ * <p>Fixed-length part contains 1 byte header and null bit set and field values. Null bit set is
+ * used for null tracking and is aligned to 8-byte word boundaries. `Field values` holds
+ * fixed-length primitive types and variable-length values which can be stored in 8 bytes inside. If
+ * it do not fit the variable-length field, then store the length and offset of variable-length
+ * part.
+ *
+ * <p>Fixed-length part will certainly fall into a MemorySegment, which will speed up the read and
+ * write of field. During the write phase, if the target memory segment has less space than fixed
+ * length part size, we will skip the space. So the number of fields in a single Row cannot exceed
+ * the capacity of a single MemorySegment, if there are too many fields, we suggest that user set a
+ * bigger pageSize of MemorySegment.
+ *
+ * <p>Variable-length part may fall into multiple MemorySegments.
+ */
+@Internal
+public final class BinaryRowData extends BinarySection
+        implements BinaryRow, NullAwareGetters, DataSetters {
+
+    private static final long serialVersionUID = 1L;
+
+    public static final boolean LITTLE_ENDIAN =
+            (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN);
+    private static final long FIRST_BYTE_ZERO = LITTLE_ENDIAN ? ~0xFFL : ~(0xFFL << 56L);
+    public static final int HEADER_SIZE_IN_BITS = 8;
+
+    public static final BinaryRowData EMPTY_ROW = new BinaryRowData(0);
+
+    static {
+        int size = EMPTY_ROW.getFixedLengthPartSize();
+        byte[] bytes = new byte[size];
+        EMPTY_ROW.pointTo(MemorySegment.wrap(bytes), 0, size);
+    }
+
+    public static int calculateBitSetWidthInBytes(int arity) {
+        return ((arity + 63 + HEADER_SIZE_IN_BITS) / 64) * 8;
+    }
+
+    public static int calculateFixPartSizeInBytes(int arity) {
+        return calculateBitSetWidthInBytes(arity) + 8 * arity;
+    }
+
+    private final int arity;
+    private final int nullBitsSizeInBytes;
+
+    public BinaryRowData(int arity) {
+        checkArgument(arity >= 0);
+        this.arity = arity;
+        this.nullBitsSizeInBytes = calculateBitSetWidthInBytes(arity);
+    }
+
+    private int getFieldOffset(int pos) {
+        return offset + nullBitsSizeInBytes + pos * 8;
+    }
+
+    private void assertIndexIsValid(int index) {
+        assert index >= 0 : "index (" + index + ") should >= 0";
+        assert index < arity : "index (" + index + ") should < " + arity;
+    }
+
+    public int getFixedLengthPartSize() {
+        return nullBitsSizeInBytes + 8 * arity;
+    }
+
+    @Override
+    public int getFieldCount() {
+        return arity;
+    }
+
+    public void setTotalSize(int sizeInBytes) {
+        this.sizeInBytes = sizeInBytes;
+    }
+
+    @Override
+    public boolean isNullAt(int pos) {
+        assertIndexIsValid(pos);
+        return BinarySegmentUtils.bitGet(segments[0], offset, pos + HEADER_SIZE_IN_BITS);
+    }
+
+    private void setNotNullAt(int i) {
+        assertIndexIsValid(i);
+        BinarySegmentUtils.bitUnSet(segments[0], offset, i + HEADER_SIZE_IN_BITS);
+    }
+
+    @Override
+    public void setNullAt(int i) {
+        assertIndexIsValid(i);
+        BinarySegmentUtils.bitSet(segments[0], offset, i + HEADER_SIZE_IN_BITS);
+        // We must set the fixed length part zero.
+        // 1.Only int/long/boolean...(Fix length type) will invoke this setNullAt.
+        // 2.Set to zero in order to equals and hash operation bytes calculation.
+        segments[0].putLong(getFieldOffset(i), 0);
+    }
+
+    @Override
+    public void setInt(int pos, int value) {
+        assertIndexIsValid(pos);
+        setNotNullAt(pos);
+        segments[0].putInt(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void setLong(int pos, long value) {
+        assertIndexIsValid(pos);
+        setNotNullAt(pos);
+        segments[0].putLong(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void setDouble(int pos, double value) {
+        assertIndexIsValid(pos);
+        setNotNullAt(pos);
+        segments[0].putDouble(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void setDecimal(int pos, Decimal value, int precision) {
+        assertIndexIsValid(pos);
+
+        if (Decimal.isCompact(precision)) {
+            // compact format
+            setLong(pos, value.toUnscaledLong());
+        } else {
+            int fieldOffset = getFieldOffset(pos);
+            int cursor = (int) (segments[0].getLong(fieldOffset) >>> 32);
+            assert cursor > 0 : "invalid cursor " + cursor;
+            // zero-out the bytes
+            BinarySegmentUtils.setLong(segments, offset + cursor, 0L);
+            BinarySegmentUtils.setLong(segments, offset + cursor + 8, 0L);
+
+            if (value == null) {
+                setNullAt(pos);
+                // keep the offset for future update
+                segments[0].putLong(fieldOffset, ((long) cursor) << 32);
+            } else {
+
+                byte[] bytes = value.toUnscaledBytes();
+                assert bytes.length <= 16;
+
+                // Write the bytes to the variable length portion.
+                BinarySegmentUtils.copyFromBytes(segments, offset + cursor, bytes, 0, bytes.length);
+                setLong(pos, ((long) cursor << 32) | ((long) bytes.length));
+            }
+        }
+    }
+
+    @Override
+    public void setTimestampLtz(int pos, TimestampLtz value, int precision) {
+        assertIndexIsValid(pos);
+
+        if (TimestampLtz.isCompact(precision)) {
+            setLong(pos, value.getEpochMillisecond());
+        } else {
+            int fieldOffset = getFieldOffset(pos);
+            int cursor = (int) (segments[0].getLong(fieldOffset) >>> 32);
+            assert cursor > 0 : "invalid cursor " + cursor;
+
+            if (value == null) {
+                setNullAt(pos);
+                // zero-out the bytes
+                BinarySegmentUtils.setLong(segments, offset + cursor, 0L);
+                // keep the offset for future update
+                segments[0].putLong(fieldOffset, ((long) cursor) << 32);
+            } else {
+                // write millisecond to the variable length portion.
+                BinarySegmentUtils.setLong(segments, offset + cursor, value.getEpochMillisecond());
+                // write nanoOfMillisecond to the fixed-length portion.
+                setLong(pos, ((long) cursor << 32) | (long) value.getNanoOfMillisecond());
+            }
+        }
+    }
+
+    public void setTimestampNtz(int pos, TimestampNtz value, int precision) {
+        assertIndexIsValid(pos);
+
+        if (TimestampNtz.isCompact(precision)) {
+            setLong(pos, value.getMillisecond());
+        } else {
+            int fieldOffset = getFieldOffset(pos);
+            int cursor = (int) (segments[0].getLong(fieldOffset) >>> 32);
+            assert cursor > 0 : "invalid cursor " + cursor;
+
+            if (value == null) {
+                setNullAt(pos);
+                // zero-out the bytes
+                BinarySegmentUtils.setLong(segments, offset + cursor, 0L);
+                // keep the offset for future update
+                segments[0].putLong(fieldOffset, ((long) cursor) << 32);
+            } else {
+                // write millisecond to the variable length portion.
+                BinarySegmentUtils.setLong(segments, offset + cursor, value.getMillisecond());
+                // write nanoOfMillisecond to the fixed-length portion.
+                setLong(pos, ((long) cursor << 32) | (long) value.getNanoOfMillisecond());
+            }
+        }
+    }
+
+    @Override
+    public void setBoolean(int pos, boolean value) {
+        assertIndexIsValid(pos);
+        setNotNullAt(pos);
+        segments[0].putBoolean(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void setShort(int pos, short value) {
+        assertIndexIsValid(pos);
+        setNotNullAt(pos);
+        segments[0].putShort(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void setByte(int pos, byte value) {
+        assertIndexIsValid(pos);
+        setNotNullAt(pos);
+        segments[0].put(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void setFloat(int pos, float value) {
+        assertIndexIsValid(pos);
+        setNotNullAt(pos);
+        segments[0].putFloat(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public boolean getBoolean(int pos) {
+        assertIndexIsValid(pos);
+        return segments[0].getBoolean(getFieldOffset(pos));
+    }
+
+    @Override
+    public byte getByte(int pos) {
+        assertIndexIsValid(pos);
+        return segments[0].get(getFieldOffset(pos));
+    }
+
+    @Override
+    public short getShort(int pos) {
+        assertIndexIsValid(pos);
+        return segments[0].getShort(getFieldOffset(pos));
+    }
+
+    @Override
+    public int getInt(int pos) {
+        assertIndexIsValid(pos);
+        return segments[0].getInt(getFieldOffset(pos));
+    }
+
+    @Override
+    public long getLong(int pos) {
+        assertIndexIsValid(pos);
+        return segments[0].getLong(getFieldOffset(pos));
+    }
+
+    @Override
+    public float getFloat(int pos) {
+        assertIndexIsValid(pos);
+        return segments[0].getFloat(getFieldOffset(pos));
+    }
+
+    @Override
+    public double getDouble(int pos) {
+        assertIndexIsValid(pos);
+        return segments[0].getDouble(getFieldOffset(pos));
+    }
+
+    @Override
+    public BinaryString getChar(int pos, int length) {
+        assertIndexIsValid(pos);
+        int fieldOffset = getFieldOffset(pos);
+        final long offsetAndLen = segments[0].getLong(fieldOffset);
+        return BinarySegmentUtils.readBinaryString(segments, offset, fieldOffset, offsetAndLen);
+    }
+
+    @Override
+    public BinaryString getString(int pos) {
+        assertIndexIsValid(pos);
+        int fieldOffset = getFieldOffset(pos);
+        final long offsetAndLen = segments[0].getLong(fieldOffset);
+        return BinarySegmentUtils.readBinaryString(segments, offset, fieldOffset, offsetAndLen);
+    }
+
+    @Override
+    public Decimal getDecimal(int pos, int precision, int scale) {
+        assertIndexIsValid(pos);
+
+        if (Decimal.isCompact(precision)) {
+            return Decimal.fromUnscaledLong(
+                    segments[0].getLong(getFieldOffset(pos)), precision, scale);
+        }
+
+        int fieldOffset = getFieldOffset(pos);
+        final long offsetAndSize = segments[0].getLong(fieldOffset);
+        return BinarySegmentUtils.readDecimalData(
+                segments, offset, offsetAndSize, precision, scale);
+    }
+
+    @Override
+    public TimestampLtz getTimestampLtz(int pos, int precision) {
+        assertIndexIsValid(pos);
+        int fieldOffset = getFieldOffset(pos);
+        if (TimestampLtz.isCompact(precision)) {
+            return TimestampLtz.fromEpochMillis(segments[0].getLong(getFieldOffset(pos)));
+        }
+        final long offsetAndNanoOfMilli = segments[0].getLong(fieldOffset);
+        return BinarySegmentUtils.readTimestampLtzData(segments, offset, offsetAndNanoOfMilli);
+    }
+
+    @Override
+    public TimestampNtz getTimestampNtz(int pos, int precision) {
+        assertIndexIsValid(pos);
+        int fieldOffset = getFieldOffset(pos);
+        if (TimestampNtz.isCompact(precision)) {
+            return TimestampNtz.fromMillis(segments[0].getLong(fieldOffset));
+        }
+        final long offsetAndNanoOfMilli = segments[0].getLong(fieldOffset);
+        return BinarySegmentUtils.readTimestampNtzData(segments, offset, offsetAndNanoOfMilli);
+    }
+
+    @Override
+    public byte[] getBinary(int pos, int length) {
+        assertIndexIsValid(pos);
+        int fieldOffset = getFieldOffset(pos);
+        final long offsetAndLen = segments[0].getLong(fieldOffset);
+        return BinarySegmentUtils.readBinary(segments, offset, fieldOffset, offsetAndLen);
+    }
+
+    @Override
+    public byte[] getBytes(int pos) {
+        assertIndexIsValid(pos);
+        int fieldOffset = getFieldOffset(pos);
+        final long offsetAndLen = segments[0].getLong(fieldOffset);
+        return BinarySegmentUtils.readBinary(segments, offset, fieldOffset, offsetAndLen);
+    }
+
+    /** The bit is 1 when the field is null. Default is 0. */
+    public boolean anyNull() {
+        // Skip the header.
+        if ((segments[0].getLong(0) & FIRST_BYTE_ZERO) != 0) {
+            return true;
+        }
+        for (int i = 8; i < nullBitsSizeInBytes; i += 8) {
+            if (segments[0].getLong(i) != 0) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean anyNull(int[] fields) {
+        for (int field : fields) {
+            if (isNullAt(field)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public BinaryRowData copy() {
+        return copy(new BinaryRowData(arity));
+    }
+
+    public BinaryRowData copy(BinaryRowData reuse) {
+        return copyInternal(reuse);
+    }
+
+    private BinaryRowData copyInternal(BinaryRowData reuse) {
+        byte[] bytes = BinarySegmentUtils.copyToBytes(segments, offset, sizeInBytes);
+        reuse.pointTo(MemorySegment.wrap(bytes), 0, sizeInBytes);
+        return reuse;
+    }
+
+    public void clear() {
+        segments = null;
+        offset = 0;
+        sizeInBytes = 0;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        // both BinaryRow and NestedRow have the same memory format
+        if (!(o instanceof BinaryRow)) {
+            return false;
+        }
+        final BinarySection that = (BinarySection) o;
+        return sizeInBytes == that.sizeInBytes
+                && BinarySegmentUtils.equals(
+                        segments, offset, that.segments, that.offset, sizeInBytes);
+    }
+
+    @Override
+    public int hashCode() {
+        return BinarySegmentUtils.hashByWords(segments, offset, sizeInBytes);
+    }
+
+    public static BinaryRowData singleColumn(@Nullable Integer i) {
+        BinaryRowData row = new BinaryRowData(1);
+        BinaryRowWriter writer = new BinaryRowWriter(row);
+        writer.reset();
+        if (i == null) {
+            writer.setNullAt(0);
+        } else {
+            writer.writeInt(0, i);
+        }
+        writer.complete();
+        return row;
+    }
+
+    public static BinaryRowData singleColumn(@Nullable String string) {
+        BinaryString binaryString = string == null ? null : BinaryString.fromString(string);
+        return singleColumn(binaryString);
+    }
+
+    public static BinaryRowData singleColumn(@Nullable BinaryString string) {
+        BinaryRowData row = new BinaryRowData(1);
+        BinaryRowWriter writer = new BinaryRowWriter(row);
+        writer.reset();
+        if (string == null) {
+            writer.setNullAt(0);
+        } else {
+            writer.writeString(0, string);
+        }
+        writer.complete();
+        return row;
+    }
+
+    /**
+     * If it is a fixed-length field, we can call this BinaryRowData's setXX method for in-place
+     * updates. If it is variable-length field, can't use this method, because the underlying data
+     * is stored continuously.
+     */
+    public static boolean isInFixedLengthPart(DataType type) {
+        switch (type.getTypeRoot()) {
+            case BOOLEAN:
+            case TINYINT:
+            case SMALLINT:
+            case INTEGER:
+            case DATE:
+            case TIME_WITHOUT_TIME_ZONE:
+            case BIGINT:
+            case FLOAT:
+            case DOUBLE:
+                return true;
+            case DECIMAL:
+                return Decimal.isCompact(((DecimalType) type).getPrecision());
+            case TIMESTAMP_WITHOUT_TIME_ZONE:
+                return TimestampLtz.isCompact(((TimestampType) type).getPrecision());
+            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
+                return TimestampNtz.isCompact(((LocalZonedTimestampType) type).getPrecision());
+            default:
+                return false;
+        }
+    }
+
+    @Override
+    public void copyTo(byte[] dst, int dstOffset) {
+        if (segments.length == 1) {
+            segments[0].get(offset, dst, dstOffset, sizeInBytes);
+        } else {
+            BinarySegmentUtils.copyToBytes(segments, offset, dst, dstOffset, sizeInBytes);
+        }
+    }
+}
diff --git a/fluss-common/src/main/java/com/alibaba/fluss/row/BinaryRowWriter.java b/fluss-common/src/main/java/com/alibaba/fluss/row/BinaryRowWriter.java
new file mode 100644
index 00000000..b882438a
--- /dev/null
+++ b/fluss-common/src/main/java/com/alibaba/fluss/row/BinaryRowWriter.java
@@ -0,0 +1,119 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.fluss.row;
+
+import com.alibaba.fluss.memory.MemorySegment;
+
+/** Writer for {@link BinaryRowData}. */
+public final class BinaryRowWriter extends AbstractBinaryWriter {
+
+    private final int nullBitsSizeInBytes;
+    private final BinaryRowData row;
+    private final int fixedSize;
+
+    public BinaryRowWriter(BinaryRowData row) {
+        this(row, 0);
+    }
+
+    public BinaryRowWriter(BinaryRowData row, int initialSize) {
+        this.nullBitsSizeInBytes = BinaryRowData.calculateBitSetWidthInBytes(row.getFieldCount());
+        this.fixedSize = row.getFixedLengthPartSize();
+        this.cursor = fixedSize;
+
+        this.segment = MemorySegment.wrap(new byte[fixedSize + initialSize]);
+        this.row = row;
+        this.row.pointTo(segment, 0, segment.size());
+    }
+
+    /** First, reset. */
+    @Override
+    public void reset() {
+        this.cursor = fixedSize;
+        for (int i = 0; i < nullBitsSizeInBytes; i += 8) {
+            segment.putLong(i, 0L);
+        }
+    }
+
+    /** Default not null. */
+    @Override
+    public void setNullAt(int pos) {
+        setNullBit(pos);
+        segment.putLong(getFieldOffset(pos), 0L);
+    }
+
+    @Override
+    public void setNullBit(int pos) {
+        BinarySegmentUtils.bitSet(segment, 0, pos + BinaryRowData.HEADER_SIZE_IN_BITS);
+    }
+
+    @Override
+    public void writeBoolean(int pos, boolean value) {
+        segment.putBoolean(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void writeByte(int pos, byte value) {
+        segment.put(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void writeShort(int pos, short value) {
+        segment.putShort(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void writeInt(int pos, int value) {
+        segment.putInt(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void writeLong(int pos, long value) {
+        segment.putLong(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void writeFloat(int pos, float value) {
+        segment.putFloat(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void writeDouble(int pos, double value) {
+        segment.putDouble(getFieldOffset(pos), value);
+    }
+
+    @Override
+    public void complete() {
+        row.setTotalSize(cursor);
+    }
+
+    @Override
+    public int getFieldOffset(int pos) {
+        return nullBitsSizeInBytes + 8 * pos;
+    }
+
+    @Override
+    public void setOffsetAndSize(int pos, int offset, long size) {
+        final long offsetAndSize = ((long) offset << 32) | size;
+        segment.putLong(getFieldOffset(pos), offsetAndSize);
+    }
+
+    @Override
+    public void afterGrow() {
+        row.pointTo(segment, 0, segment.size());
+    }
+}
diff --git a/fluss-common/src/main/java/com/alibaba/fluss/row/BinarySection.java b/fluss-common/src/main/java/com/alibaba/fluss/row/BinarySection.java
index 9189f790..68c0c4d2 100644
--- a/fluss-common/src/main/java/com/alibaba/fluss/row/BinarySection.java
+++ b/fluss-common/src/main/java/com/alibaba/fluss/row/BinarySection.java
@@ -35,6 +35,34 @@ abstract class BinarySection implements MemoryAwareGetters, Serializable {
 
     private static final long serialVersionUID = 1L;
 
+    /**
+     * It decides whether to put data in FixLenPart or VarLenPart. See more in {@link BinaryRow}.
+     *
+     * <p>If len is less than 8, its binary format is: 1-bit mark(1) = 1, 7-bits len, and 7-bytes
+     * data. Data is stored in fix-length part.
+     *
+     * <p>If len is greater or equal to 8, its binary format is: 1-bit mark(1) = 0, 31-bits offset
+     * to the data, and 4-bytes length of data. Data is stored in variable-length part.
+     */
+    public static final int MAX_FIX_PART_DATA_SIZE = 7;
+
+    /**
+     * To get the mark in highest bit of long. Form: 10000000 00000000 ... (8 bytes)
+     *
+     * <p>This is used to decide whether the data is stored in fixed-length part or variable-length
+     * part. see {@link #MAX_FIX_PART_DATA_SIZE} for more information.
+     */
+    public static final long HIGHEST_FIRST_BIT = 0x80L << 56;
+
+    /**
+     * To get the 7 bits length in second bit to eighth bit out of a long. Form: 01111111 00000000
+     * ... (8 bytes)
+     *
+     * <p>This is used to get the length of the data which is stored in this long. see {@link
+     * #MAX_FIX_PART_DATA_SIZE} for more information.
+     */
+    public static final long HIGHEST_SECOND_TO_EIGHTH_BIT = 0x7FL << 56;
+
     protected MemorySegment[] segments;
     protected int offset;
     protected int sizeInBytes;
diff --git a/fluss-common/src/main/java/com/alibaba/fluss/row/BinarySegmentUtils.java b/fluss-common/src/main/java/com/alibaba/fluss/row/BinarySegmentUtils.java
index 7595ef71..74238ace 100644
--- a/fluss-common/src/main/java/com/alibaba/fluss/row/BinarySegmentUtils.java
+++ b/fluss-common/src/main/java/com/alibaba/fluss/row/BinarySegmentUtils.java
@@ -23,8 +23,11 @@ import com.alibaba.fluss.memory.OutputView;
 import com.alibaba.fluss.utils.MurmurHashUtils;
 
 import java.io.IOException;
+import java.nio.ByteOrder;
 
 import static com.alibaba.fluss.memory.MemoryUtils.UNSAFE;
+import static com.alibaba.fluss.row.BinarySection.HIGHEST_FIRST_BIT;
+import static com.alibaba.fluss.row.BinarySection.HIGHEST_SECOND_TO_EIGHTH_BIT;
 
 /* This file is based on source code of Apache Flink Project (https://flink.apache.org/), licensed by the Apache
  * Software Foundation (ASF) under the Apache License, Version 2.0. See the NOTICE file distributed with this work for
@@ -34,6 +37,9 @@ import static com.alibaba.fluss.memory.MemoryUtils.UNSAFE;
 @Internal
 public final class BinarySegmentUtils {
 
+    public static final boolean LITTLE_ENDIAN =
+            (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN);
+
     private static final int ADDRESS_BITS_PER_WORD = 3;
 
     private static final int BIT_BYTE_INDEX_MASK = 7;
@@ -368,6 +374,20 @@ public final class BinarySegmentUtils {
         return bitIndex >>> ADDRESS_BITS_PER_WORD;
     }
 
+    /**
+     * unset bit.
+     *
+     * @param segment target segment.
+     * @param baseOffset bits base offset.
+     * @param index bit index from base offset.
+     */
+    public static void bitUnSet(MemorySegment segment, int baseOffset, int index) {
+        int offset = baseOffset + byteIndex(index);
+        byte current = segment.get(offset);
+        current &= ~(1 << (index & BIT_BYTE_INDEX_MASK));
+        segment.put(offset, current);
+    }
+
     /**
      * read bit.
      *
@@ -386,4 +406,276 @@ public final class BinarySegmentUtils {
         copyMultiSegmentsToBytes(segments, offset, bytes, 0, numBytes);
         return MurmurHashUtils.hashUnsafeBytes(bytes, BYTE_ARRAY_BASE_OFFSET, numBytes);
     }
+
+    /**
+     * get long from segments.
+     *
+     * @param segments target segments.
+     * @param offset value offset.
+     */
+    public static long getLong(MemorySegment[] segments, int offset) {
+        if (inFirstSegment(segments, offset, 8)) {
+            return segments[0].getLong(offset);
+        } else {
+            return getLongMultiSegments(segments, offset);
+        }
+    }
+
+    private static long getLongMultiSegments(MemorySegment[] segments, int offset) {
+        int segSize = segments[0].size();
+        int segIndex = offset / segSize;
+        int segOffset = offset - segIndex * segSize; // equal to %
+
+        if (segOffset < segSize - 7) {
+            return segments[segIndex].getLong(segOffset);
+        } else {
+            return getLongSlowly(segments, segSize, segIndex, segOffset);
+        }
+    }
+
+    private static long getLongSlowly(
+            MemorySegment[] segments, int segSize, int segNum, int segOffset) {
+        MemorySegment segment = segments[segNum];
+        long ret = 0;
+        for (int i = 0; i < 8; i++) {
+            if (segOffset == segSize) {
+                segment = segments[++segNum];
+                segOffset = 0;
+            }
+            long unsignedByte = segment.get(segOffset) & 0xff;
+            if (LITTLE_ENDIAN) {
+                ret |= (unsignedByte << (i * 8));
+            } else {
+                ret |= (unsignedByte << ((7 - i) * 8));
+            }
+            segOffset++;
+        }
+        return ret;
+    }
+
+    /**
+     * set long from segments.
+     *
+     * @param segments target segments.
+     * @param offset value offset.
+     */
+    public static void setLong(MemorySegment[] segments, int offset, long value) {
+        if (inFirstSegment(segments, offset, 8)) {
+            segments[0].putLong(offset, value);
+        } else {
+            setLongMultiSegments(segments, offset, value);
+        }
+    }
+
+    private static void setLongMultiSegments(MemorySegment[] segments, int offset, long value) {
+        int segSize = segments[0].size();
+        int segIndex = offset / segSize;
+        int segOffset = offset - segIndex * segSize; // equal to %
+
+        if (segOffset < segSize - 7) {
+            segments[segIndex].putLong(segOffset, value);
+        } else {
+            setLongSlowly(segments, segSize, segIndex, segOffset, value);
+        }
+    }
+
+    private static void setLongSlowly(
+            MemorySegment[] segments, int segSize, int segNum, int segOffset, long value) {
+        MemorySegment segment = segments[segNum];
+        for (int i = 0; i < 8; i++) {
+            if (segOffset == segSize) {
+                segment = segments[++segNum];
+                segOffset = 0;
+            }
+            long unsignedByte;
+            if (LITTLE_ENDIAN) {
+                unsignedByte = value >> (i * 8);
+            } else {
+                unsignedByte = value >> ((7 - i) * 8);
+            }
+            segment.put(segOffset, (byte) unsignedByte);
+            segOffset++;
+        }
+    }
+
+    /**
+     * Copy target segments from source byte[].
+     *
+     * @param segments target segments.
+     * @param offset target segments offset.
+     * @param bytes source byte[].
+     * @param bytesOffset source byte[] offset.
+     * @param numBytes the number bytes to copy.
+     */
+    public static void copyFromBytes(
+            MemorySegment[] segments, int offset, byte[] bytes, int bytesOffset, int numBytes) {
+        if (segments.length == 1) {
+            segments[0].put(offset, bytes, bytesOffset, numBytes);
+        } else {
+            copyMultiSegmentsFromBytes(segments, offset, bytes, bytesOffset, numBytes);
+        }
+    }
+
+    private static void copyMultiSegmentsFromBytes(
+            MemorySegment[] segments, int offset, byte[] bytes, int bytesOffset, int numBytes) {
+        int remainSize = numBytes;
+        for (MemorySegment segment : segments) {
+            int remain = segment.size() - offset;
+            if (remain > 0) {
+                int nCopy = Math.min(remain, remainSize);
+                segment.put(offset, bytes, numBytes - remainSize + bytesOffset, nCopy);
+                remainSize -= nCopy;
+                // next new segment.
+                offset = 0;
+                if (remainSize == 0) {
+                    return;
+                }
+            } else {
+                // remain is negative, let's advance to next segment
+                // now the offset = offset - segmentSize (-remain)
+                offset = -remain;
+            }
+        }
+    }
+
+    /** Gets an instance of {@link Decimal} from underlying {@link MemorySegment}. */
+    public static Decimal readDecimalData(
+            MemorySegment[] segments,
+            int baseOffset,
+            long offsetAndSize,
+            int precision,
+            int scale) {
+        final int size = ((int) offsetAndSize);
+        int subOffset = (int) (offsetAndSize >> 32);
+        byte[] bytes = new byte[size];
+        copyToBytes(segments, baseOffset + subOffset, bytes, 0, size);
+        return Decimal.fromUnscaledBytes(bytes, precision, scale);
+    }
+
+    /**
+     * Get binary, if len less than 8, will be include in variablePartOffsetAndLen.
+     *
+     * <p>Note: Need to consider the ByteOrder.
+     *
+     * @param baseOffset base offset of composite binary format.
+     * @param fieldOffset absolute start offset of 'variablePartOffsetAndLen'.
+     * @param variablePartOffsetAndLen a long value, real data or offset and len.
+     */
+    public static byte[] readBinary(
+            MemorySegment[] segments,
+            int baseOffset,
+            int fieldOffset,
+            long variablePartOffsetAndLen) {
+        long mark = variablePartOffsetAndLen & HIGHEST_FIRST_BIT;
+        if (mark == 0) {
+            final int subOffset = (int) (variablePartOffsetAndLen >> 32);
+            final int len = (int) variablePartOffsetAndLen;
+            return BinarySegmentUtils.copyToBytes(segments, baseOffset + subOffset, len);
+        } else {
+            // Data is stored in fixed-length part (≤7 bytes)
+            int len = (int) ((variablePartOffsetAndLen & HIGHEST_SECOND_TO_EIGHTH_BIT) >>> 56);
+            byte[] result = new byte[len];
+
+            // Extract the actual data bytes from the low 7 bytes of the long value
+            long dataBytes =
+                    variablePartOffsetAndLen & 0x00FFFFFFFFFFFFFFL; // Mask out the header byte
+
+            if (BinarySegmentUtils.LITTLE_ENDIAN) {
+                // For little endian: byte[i] was stored at position (i * 8)
+                for (int i = 0; i < len; i++) {
+                    result[i] = (byte) ((dataBytes >>> (i * 8)) & 0xFF);
+                }
+            } else {
+                // For big endian: byte[i] was stored at position ((6 - i) * 8)
+                for (int i = 0; i < len; i++) {
+                    result[i] = (byte) ((dataBytes >>> ((6 - i) * 8)) & 0xFF);
+                }
+            }
+
+            return result;
+        }
+    }
+
+    /**
+     * Get binary string, if len less than 8, will be include in variablePartOffsetAndLen.
+     *
+     * <p>Note: Need to consider the ByteOrder.
+     *
+     * @param baseOffset base offset of composite binary format.
+     * @param fieldOffset absolute start offset of 'variablePartOffsetAndLen'.
+     * @param variablePartOffsetAndLen a long value, real data or offset and len.
+     */
+    public static BinaryString readBinaryString(
+            MemorySegment[] segments,
+            int baseOffset,
+            int fieldOffset,
+            long variablePartOffsetAndLen) {
+        long mark = variablePartOffsetAndLen & HIGHEST_FIRST_BIT;
+        if (mark == 0) {
+            final int subOffset = (int) (variablePartOffsetAndLen >> 32);
+            final int len = (int) variablePartOffsetAndLen;
+            return BinaryString.fromAddress(segments, baseOffset + subOffset, len);
+        } else {
+            int len = (int) ((variablePartOffsetAndLen & HIGHEST_SECOND_TO_EIGHTH_BIT) >>> 56);
+            if (BinarySegmentUtils.LITTLE_ENDIAN) {
+                return BinaryString.fromAddress(segments, fieldOffset, len);
+            } else {
+                // fieldOffset + 1 to skip header.
+                return BinaryString.fromAddress(segments, fieldOffset + 1, len);
+            }
+        }
+    }
+
+    /**
+     * hash segments to int, numBytes must be aligned to 4 bytes.
+     *
+     * @param segments Source segments.
+     * @param offset Source segments offset.
+     * @param numBytes the number bytes to hash.
+     */
+    public static int hashByWords(MemorySegment[] segments, int offset, int numBytes) {
+        if (inFirstSegment(segments, offset, numBytes)) {
+            return MurmurHashUtils.hashBytesByWords(segments[0], offset, numBytes);
+        } else {
+            return hashMultiSegByWords(segments, offset, numBytes);
+        }
+    }
+
+    private static int hashMultiSegByWords(MemorySegment[] segments, int offset, int numBytes) {
+        byte[] bytes = allocateReuseBytes(numBytes);
+        copyMultiSegmentsToBytes(segments, offset, bytes, 0, numBytes);
+        return MurmurHashUtils.hashUnsafeBytesByWords(bytes, BYTE_ARRAY_BASE_OFFSET, numBytes);
+    }
+
+    /**
+     * Gets an instance of {@link TimestampLtz} from underlying {@link MemorySegment}.
+     *
+     * @param segments the underlying MemorySegments
+     * @param baseOffset the base offset of current instance of {@code TimestampLtz}
+     * @param offsetAndNanos the offset of milli-seconds part and nanoseconds
+     * @return an instance of {@link TimestampLtz}
+     */
+    public static TimestampLtz readTimestampLtzData(
+            MemorySegment[] segments, int baseOffset, long offsetAndNanos) {
+        final int nanoOfMillisecond = (int) offsetAndNanos;
+        final int subOffset = (int) (offsetAndNanos >> 32);
+        final long millisecond = getLong(segments, baseOffset + subOffset);
+        return TimestampLtz.fromEpochMillis(millisecond, nanoOfMillisecond);
+    }
+
+    /**
+     * Gets an instance of {@link TimestampNtz} from underlying {@link MemorySegment}.
+     *
+     * @param segments the underlying MemorySegments
+     * @param baseOffset the base offset of current instance of {@code TimestampNtz}
+     * @param offsetAndNanos the offset of milli-seconds part and nanoseconds
+     * @return an instance of {@link TimestampNtz}
+     */
+    public static TimestampNtz readTimestampNtzData(
+            MemorySegment[] segments, int baseOffset, long offsetAndNanos) {
+        final int nanoOfMillisecond = (int) offsetAndNanos;
+        final int subOffset = (int) (offsetAndNanos >> 32);
+        final long millisecond = getLong(segments, baseOffset + subOffset);
+        return TimestampNtz.fromMillis(millisecond, nanoOfMillisecond);
+    }
 }
diff --git a/fluss-common/src/main/java/com/alibaba/fluss/row/BinaryWriter.java b/fluss-common/src/main/java/com/alibaba/fluss/row/BinaryWriter.java
new file mode 100644
index 00000000..9b6042b3
--- /dev/null
+++ b/fluss-common/src/main/java/com/alibaba/fluss/row/BinaryWriter.java
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.fluss.row;
+
+import com.alibaba.fluss.types.DataType;
+import com.alibaba.fluss.types.DecimalType;
+import com.alibaba.fluss.types.LocalZonedTimestampType;
+import com.alibaba.fluss.types.TimestampType;
+
+/**
+ * Writer to write a composite data format, like row, array. 1. Invoke {@link #reset()}. 2. Write
+ * each field by writeXX or setNullAt. (Same field can not be written repeatedly.) 3. Invoke {@link
+ * #complete()}.
+ */
+public interface BinaryWriter {
+
+    /** Reset writer to prepare next write. */
+    void reset();
+
+    /** Set null to this field. */
+    void setNullAt(int pos);
+
+    void writeBoolean(int pos, boolean value);
+
+    void writeByte(int pos, byte value);
+
+    void writeShort(int pos, short value);
+
+    void writeInt(int pos, int value);
+
+    void writeLong(int pos, long value);
+
+    void writeFloat(int pos, float value);
+
+    void writeDouble(int pos, double value);
+
+    void writeString(int pos, BinaryString value);
+
+    void writeBinary(int pos, byte[] bytes);
+
+    void writeDecimal(int pos, Decimal value, int precision);
+
+    void writeTimestampLtz(int pos, TimestampLtz value, int precision);
+
+    void writeTimestampNtz(int pos, TimestampNtz value, int precision);
+
+    /** Finally, complete write to set real size to binary. */
+    void complete();
+
+    // --------------------------------------------------------------------------------------------
+
+    /**
+     * @deprecated Use {@code #createValueSetter(DataType)} for avoiding logical types during
+     *     runtime.
+     */
+    @Deprecated
+    static void write(BinaryWriter writer, int pos, Object o, DataType type) {
+        switch (type.getTypeRoot()) {
+            case BOOLEAN:
+                writer.writeBoolean(pos, (boolean) o);
+                break;
+            case TINYINT:
+                writer.writeByte(pos, (byte) o);
+                break;
+            case SMALLINT:
+                writer.writeShort(pos, (short) o);
+                break;
+            case INTEGER:
+            case DATE:
+            case TIME_WITHOUT_TIME_ZONE:
+                writer.writeInt(pos, (int) o);
+                break;
+            case BIGINT:
+                writer.writeLong(pos, (long) o);
+                break;
+            case TIMESTAMP_WITHOUT_TIME_ZONE:
+                TimestampType timestampType = (TimestampType) type;
+                writer.writeTimestampNtz(pos, (TimestampNtz) o, timestampType.getPrecision());
+                break;
+            case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
+                LocalZonedTimestampType lzTs = (LocalZonedTimestampType) type;
+                writer.writeTimestampLtz(pos, (TimestampLtz) o, lzTs.getPrecision());
+                break;
+            case FLOAT:
+                writer.writeFloat(pos, (float) o);
+                break;
+            case DOUBLE:
+                writer.writeDouble(pos, (double) o);
+                break;
+            case CHAR:
+            case STRING:
+                writer.writeString(pos, (BinaryString) o);
+                break;
+            case DECIMAL:
+                DecimalType decimalType = (DecimalType) type;
+                writer.writeDecimal(pos, (Decimal) o, decimalType.getPrecision());
+                break;
+            case BINARY:
+                writer.writeBinary(pos, (byte[]) o);
+                break;
+            default:
+                throw new UnsupportedOperationException("Not support type: " + type);
+        }
+    }
+}
diff --git a/fluss-common/src/main/java/com/alibaba/fluss/row/DataSetters.java b/fluss-common/src/main/java/com/alibaba/fluss/row/DataSetters.java
new file mode 100644
index 00000000..17f063a7
--- /dev/null
+++ b/fluss-common/src/main/java/com/alibaba/fluss/row/DataSetters.java
@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.fluss.row;
+
+/**
+ * Provide type specialized setters to reduce if/else and eliminate box and unbox. This is mainly
+ * used on the binary format such as {@link BinaryRow}.
+ */
+public interface DataSetters {
+
+    void setNullAt(int pos);
+
+    void setBoolean(int pos, boolean value);
+
+    void setByte(int pos, byte value);
+
+    void setShort(int pos, short value);
+
+    void setInt(int pos, int value);
+
+    void setLong(int pos, long value);
+
+    void setFloat(int pos, float value);
+
+    void setDouble(int pos, double value);
+
+    /**
+     * Set the decimal column value.
+     *
+     * <p>Note: Precision is compact: can call {@link #setNullAt} when decimal is null. Precision is
+     * not compact: can not call {@link #setNullAt} when decimal is null, must call {@code
+     * setDecimal(pos, null, precision)} because we need update var-length-part.
+     */
+    void setDecimal(int pos, Decimal value, int precision);
+
+    /**
+     * Set TimestampLtz value.
+     *
+     * <p>Note: If precision is compact: can call {@link #setNullAt} when TimestampLtz value is
+     * null. Otherwise: can not call {@link #setNullAt} when TimestampLtz value is null, must call
+     * {@code setTimestampLtz(pos, null, precision)} because we need to update var-length-part.
+     */
+    void setTimestampLtz(int pos, TimestampLtz value, int precision);
+
+    /**
+     * Set TimestampNtz value.
+     *
+     * <p>Note: If precision is compact: can call {@link #setNullAt} when TimestampNtz value is
+     * null. Otherwise: can not call {@link #setNullAt} when TimestampNtz value is null, must call
+     * {@code setTimestampNtz(pos, null, precision)} because we need to update var-length-part.
+     */
+    void setTimestampNtz(int pos, TimestampNtz value, int precision);
+}
diff --git a/fluss-common/src/main/java/com/alibaba/fluss/utils/MurmurHashUtils.java b/fluss-common/src/main/java/com/alibaba/fluss/utils/MurmurHashUtils.java
index 7633fa6d..f167d543 100644
--- a/fluss-common/src/main/java/com/alibaba/fluss/utils/MurmurHashUtils.java
+++ b/fluss-common/src/main/java/com/alibaba/fluss/utils/MurmurHashUtils.java
@@ -33,6 +33,18 @@ public class MurmurHashUtils {
     private static final int C2 = 0x1b873593;
     public static final int DEFAULT_SEED = 42;
 
+    /**
+     * Hash unsafe bytes, length must be aligned to 4 bytes.
+     *
+     * @param base base unsafe object
+     * @param offset offset for unsafe object
+     * @param lengthInBytes length in bytes
+     * @return hash code
+     */
+    public static int hashUnsafeBytesByWords(Object base, long offset, int lengthInBytes) {
+        return hashUnsafeBytesByWords(base, offset, lengthInBytes, DEFAULT_SEED);
+    }
+
     /**
      * Hash bytes in MemorySegment.
      *
@@ -62,6 +74,18 @@ public class MurmurHashUtils {
         return hashUnsafeBytes(base, offset, lengthInBytes, DEFAULT_SEED);
     }
 
+    /**
+     * Hash bytes in MemorySegment, length must be aligned to 4 bytes.
+     *
+     * @param segment segment.
+     * @param offset offset for MemorySegment
+     * @param lengthInBytes length in MemorySegment
+     * @return hash code
+     */
+    public static int hashBytesByWords(MemorySegment segment, int offset, int lengthInBytes) {
+        return hashBytesByWords(segment, offset, lengthInBytes, DEFAULT_SEED);
+    }
+
     private static int hashBytes(MemorySegment segment, int offset, int lengthInBytes, int seed) {
         int lengthAligned = lengthInBytes - lengthInBytes % 4;
         int h1 = hashBytesByInt(segment, offset, lengthAligned, seed);
@@ -107,6 +131,18 @@ public class MurmurHashUtils {
         return fmix(h1, lengthInBytes);
     }
 
+    private static int hashUnsafeBytesByWords(
+            Object base, long offset, int lengthInBytes, int seed) {
+        int h1 = hashUnsafeBytesByInt(base, offset, lengthInBytes, seed);
+        return fmix(h1, lengthInBytes);
+    }
+
+    private static int hashBytesByWords(
+            MemorySegment segment, int offset, int lengthInBytes, int seed) {
+        int h1 = hashBytesByInt(segment, offset, lengthInBytes, seed);
+        return fmix(h1, lengthInBytes);
+    }
+
     // Finalization mix - force all bits of a hash block to avalanche
     private static int fmix(int h1, int length) {
         h1 ^= length;
diff --git a/fluss-common/src/test/java/com/alibaba/fluss/row/BinaryRowDataTest.java b/fluss-common/src/test/java/com/alibaba/fluss/row/BinaryRowDataTest.java
new file mode 100644
index 00000000..55333a32
--- /dev/null
+++ b/fluss-common/src/test/java/com/alibaba/fluss/row/BinaryRowDataTest.java
@@ -0,0 +1,477 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.fluss.row;
+
+import com.alibaba.fluss.memory.MemorySegment;
+
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.nio.charset.StandardCharsets;
+import java.time.LocalDateTime;
+import java.util.HashSet;
+import java.util.Random;
+import java.util.Set;
+import java.util.function.Consumer;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** Test for {@link BinaryRowData}. */
+class BinaryRowDataTest {
+
+    @Test
+    public void testBasic() {
+        // consider header 1 byte.
+        assertThat(new BinaryRowData(0).getFixedLengthPartSize()).isEqualTo(8);
+        assertThat(new BinaryRowData(1).getFixedLengthPartSize()).isEqualTo(16);
+        assertThat(new BinaryRowData(65).getFixedLengthPartSize()).isEqualTo(536);
+        assertThat(new BinaryRowData(128).getFixedLengthPartSize()).isEqualTo(1048);
+
+        MemorySegment segment = MemorySegment.wrap(new byte[100]);
+        BinaryRowData row = new BinaryRowData(2);
+        row.pointTo(segment, 10, 48);
+        assertThat(segment).isSameAs(row.getSegments()[0]);
+        row.setInt(0, 5);
+        row.setDouble(1, 5.8D);
+    }
+
+    @Test
+    public void testSetAndGet() throws IOException, ClassNotFoundException {
+        MemorySegment segment = MemorySegment.wrap(new byte[100]);
+        BinaryRowData row = new BinaryRowData(9);
+        row.pointTo(segment, 20, 80);
+        row.setNullAt(0);
+        row.setInt(1, 11);
+        row.setLong(2, 22);
+        row.setDouble(3, 33);
+        row.setBoolean(4, true);
+        row.setShort(5, (short) 55);
+        row.setByte(6, (byte) 66);
+        row.setFloat(7, 77f);
+
+        Consumer<BinaryRow> assertConsumer =
+                assertRow -> {
+                    assertThat((long) assertRow.getDouble(3)).isEqualTo(33L);
+                    assertThat(assertRow.getInt(1)).isEqualTo(11);
+                    assertThat(assertRow.isNullAt(0)).isTrue();
+                    assertThat(assertRow.getShort(5)).isEqualTo((short) 55);
+                    assertThat(assertRow.getLong(2)).isEqualTo(22L);
+                    assertThat(assertRow.getBoolean(4)).isTrue();
+                    assertThat(assertRow.getByte(6)).isEqualTo((byte) 66);
+                    assertThat(assertRow.getFloat(7)).isEqualTo(77f);
+                };
+
+        assertConsumer.accept(row);
+    }
+
+    @Test
+    public void testWriter() {
+
+        int arity = 13;
+        BinaryRowData row = new BinaryRowData(arity);
+        BinaryRowWriter writer = new BinaryRowWriter(row, 20);
+
+        writer.writeString(0, BinaryString.fromString("1"));
+        writer.writeString(3, BinaryString.fromString("1234567"));
+        writer.writeString(5, BinaryString.fromString("12345678"));
+        writer.writeString(
+                9, BinaryString.fromString("God in his heaven, alls right with the world"));
+
+        writer.writeBoolean(1, true);
+        writer.writeByte(2, (byte) 99);
+        writer.writeDouble(6, 87.1d);
+        writer.writeFloat(7, 26.1f);
+        writer.writeInt(8, 88);
+        writer.writeLong(10, 284);
+        writer.writeShort(11, (short) 292);
+        writer.setNullAt(12);
+
+        writer.complete();
+
+        assertTestWriterRow(row);
+        assertTestWriterRow(row.copy());
+
+        // test copy from var segments.
+        int subSize = row.getFixedLengthPartSize() + 10;
+        MemorySegment subMs1 = MemorySegment.wrap(new byte[subSize]);
+        MemorySegment subMs2 = MemorySegment.wrap(new byte[subSize]);
+        row.getSegments()[0].copyTo(0, subMs1, 0, subSize);
+        row.getSegments()[0].copyTo(subSize, subMs2, 0, row.getSizeInBytes() - subSize);
+
+        BinaryRowData toCopy = new BinaryRowData(arity);
+        toCopy.pointTo(new MemorySegment[] {subMs1, subMs2}, 0, row.getSizeInBytes());
+        assertThat(toCopy).isEqualTo(row);
+        assertTestWriterRow(toCopy);
+        assertTestWriterRow(toCopy.copy(new BinaryRowData(arity)));
+    }
+
+    @Test
+    public void testWriteString() {
+        {
+            // litter byte[]
+            BinaryRowData row = new BinaryRowData(1);
+            BinaryRowWriter writer = new BinaryRowWriter(row);
+            char[] chars = new char[2];
+            chars[0] = 0xFFFF;
+            chars[1] = 0;
+            writer.writeString(0, BinaryString.fromString(new String(chars)));
+            writer.complete();
+
+            String str = row.getString(0).toString();
+            assertThat(str.charAt(0)).isEqualTo(chars[0]);
+            assertThat(str.charAt(1)).isEqualTo(chars[1]);
+        }
+
+        {
+            // big byte[]
+            String str = "God in his heaven, alls right with the world";
+            BinaryRowData row = new BinaryRowData(2);
+            BinaryRowWriter writer = new BinaryRowWriter(row);
+            writer.writeString(0, BinaryString.fromString(str));
+            writer.writeString(1, BinaryString.fromBytes(str.getBytes(StandardCharsets.UTF_8)));
+            writer.complete();
+
+            assertThat(row.getString(0).toString()).isEqualTo(str);
+            assertThat(row.getString(1).toString()).isEqualTo(str);
+        }
+    }
+
+    private void assertTestWriterRow(BinaryRowData row) {
+        assertThat(row.getString(0).toString()).isEqualTo("1");
+        assertThat(row.getInt(8)).isEqualTo(88);
+        assertThat(row.getShort(11)).isEqualTo((short) 292);
+        assertThat(row.getLong(10)).isEqualTo(284);
+        assertThat(row.getByte(2)).isEqualTo((byte) 99);
+        assertThat(row.getDouble(6)).isEqualTo(87.1d);
+        assertThat(row.getFloat(7)).isEqualTo(26.1f);
+        assertThat(row.getBoolean(1)).isTrue();
+        assertThat(row.getString(3).toString()).isEqualTo("1234567");
+        assertThat(row.getString(5).toString()).isEqualTo("12345678");
+        assertThat(row.getString(9).toString())
+                .isEqualTo("God in his heaven, alls right with the world");
+        assertThat(row.getString(9).hashCode())
+                .isEqualTo(
+                        BinaryString.fromString("God in his heaven, alls right with the world")
+                                .hashCode());
+        assertThat(row.isNullAt(12)).isTrue();
+    }
+
+    @Test
+    public void testReuseWriter() {
+        BinaryRowData row = new BinaryRowData(2);
+        BinaryRowWriter writer = new BinaryRowWriter(row);
+        writer.writeString(0, BinaryString.fromString("01234567"));
+        writer.writeString(1, BinaryString.fromString("012345678"));
+        writer.complete();
+        assertThat(row.getString(0).toString()).isEqualTo("01234567");
+        assertThat(row.getString(1).toString()).isEqualTo("012345678");
+
+        writer.reset();
+        writer.writeString(0, BinaryString.fromString("1"));
+        writer.writeString(1, BinaryString.fromString("0123456789"));
+        writer.complete();
+        assertThat(row.getString(0).toString()).isEqualTo("1");
+        assertThat(row.getString(1).toString()).isEqualTo("0123456789");
+    }
+
+    @Test
+    public void anyNullTest() {
+        {
+            BinaryRowData row = new BinaryRowData(3);
+            BinaryRowWriter writer = new BinaryRowWriter(row);
+            assertThat(row.anyNull()).isFalse();
+
+            // test header should not compute by anyNull
+            assertThat(row.anyNull()).isFalse();
+
+            writer.setNullAt(2);
+            assertThat(row.anyNull()).isTrue();
+
+            writer.setNullAt(0);
+            assertThat(row.anyNull(new int[] {0, 1, 2})).isTrue();
+            assertThat(row.anyNull(new int[] {1})).isFalse();
+
+            writer.setNullAt(1);
+            assertThat(row.anyNull()).isTrue();
+        }
+
+        int numFields = 80;
+        for (int i = 0; i < numFields; i++) {
+            BinaryRowData row = new BinaryRowData(numFields);
+            BinaryRowWriter writer = new BinaryRowWriter(row);
+            assertThat(row.anyNull()).isFalse();
+            writer.setNullAt(i);
+            assertThat(row.anyNull()).isTrue();
+        }
+    }
+
+    @Test
+    public void testSingleSegmentBinaryRowHashCode() {
+        final Random rnd = new Random(System.currentTimeMillis());
+        // test hash stabilization
+        BinaryRowData row = new BinaryRowData(13);
+        BinaryRowWriter writer = new BinaryRowWriter(row);
+        for (int i = 0; i < 99; i++) {
+            writer.reset();
+            writer.writeString(0, BinaryString.fromString("" + rnd.nextInt()));
+            writer.writeString(3, BinaryString.fromString("01234567"));
+            writer.writeString(5, BinaryString.fromString("012345678"));
+            writer.writeString(
+                    9, BinaryString.fromString("God in his heaven, alls right with the world"));
+            writer.writeBoolean(1, true);
+            writer.writeByte(2, (byte) 99);
+            writer.writeDouble(6, 87.1d);
+            writer.writeFloat(7, 26.1f);
+            writer.writeInt(8, 88);
+            writer.writeLong(10, 284);
+            writer.writeShort(11, (short) 292);
+            writer.setNullAt(12);
+            writer.complete();
+            BinaryRowData copy = row.copy();
+            assertThat(copy.hashCode()).isEqualTo(row.hashCode());
+        }
+
+        // test hash distribution
+        int count = 999999;
+        Set<Integer> hashCodes = new HashSet<>(count);
+        for (int i = 0; i < count; i++) {
+            row.setInt(8, i);
+            hashCodes.add(row.hashCode());
+        }
+        assertThat(hashCodes).hasSize(count);
+        hashCodes.clear();
+        row = new BinaryRowData(1);
+        writer = new BinaryRowWriter(row);
+        for (int i = 0; i < count; i++) {
+            writer.reset();
+            writer.writeString(
+                    0, BinaryString.fromString("God in his heaven, alls right with the world" + i));
+            writer.complete();
+            hashCodes.add(row.hashCode());
+        }
+        assertThat(hashCodes.size()).isGreaterThan((int) (count * 0.997));
+    }
+
+    @Test
+    public void testHeaderSize() {
+        assertThat(BinaryRowData.calculateBitSetWidthInBytes(56)).isEqualTo(8);
+        assertThat(BinaryRowData.calculateBitSetWidthInBytes(57)).isEqualTo(16);
+        assertThat(BinaryRowData.calculateBitSetWidthInBytes(120)).isEqualTo(16);
+        assertThat(BinaryRowData.calculateBitSetWidthInBytes(121)).isEqualTo(24);
+    }
+
+    @Test
+    public void testHeader() {
+        BinaryRowData row = new BinaryRowData(2);
+        BinaryRowWriter writer = new BinaryRowWriter(row);
+
+        writer.writeInt(0, 10);
+        writer.setNullAt(1);
+        writer.complete();
+
+        BinaryRowData newRow = row.copy();
+        assertThat(newRow).isEqualTo(row);
+    }
+
+    @Test
+    public void testDecimal() {
+        // 1.compact
+        {
+            int precision = 4;
+            int scale = 2;
+            BinaryRowData row = new BinaryRowData(2);
+            BinaryRowWriter writer = new BinaryRowWriter(row);
+            writer.writeDecimal(0, Decimal.fromUnscaledLong(5, precision, scale), precision);
+            writer.setNullAt(1);
+            writer.complete();
+
+            assertThat(row.getDecimal(0, precision, scale).toString()).isEqualTo("0.05");
+            assertThat(row.isNullAt(1)).isTrue();
+            row.setDecimal(0, Decimal.fromUnscaledLong(6, precision, scale), precision);
+            assertThat(row.getDecimal(0, precision, scale).toString()).isEqualTo("0.06");
+        }
+
+        // 2.not compact
+        {
+            int precision = 25;
+            int scale = 5;
+            Decimal decimal1 = Decimal.fromBigDecimal(BigDecimal.valueOf(5.55), precision, scale);
+            Decimal decimal2 = Decimal.fromBigDecimal(BigDecimal.valueOf(6.55), precision, scale);
+
+            BinaryRowData row = new BinaryRowData(2);
+            BinaryRowWriter writer = new BinaryRowWriter(row);
+            writer.writeDecimal(0, decimal1, precision);
+            writer.writeDecimal(1, null, precision);
+            writer.complete();
+
+            assertThat(row.getDecimal(0, precision, scale).toString()).isEqualTo("5.55000");
+            assertThat(row.isNullAt(1)).isTrue();
+            row.setDecimal(0, decimal2, precision);
+            assertThat(row.getDecimal(0, precision, scale).toString()).isEqualTo("6.55000");
+        }
+    }
+
+    @Test
+    public void testBinary() {
+        BinaryRowData row = new BinaryRowData(2);
+        BinaryRowWriter writer = new BinaryRowWriter(row);
+        byte[] bytes1 = new byte[] {1, -1, 5};
+        byte[] bytes2 = new byte[] {1, -1, 5, 5, 1, 5, 1, 5};
+        writer.writeBinary(0, bytes1);
+        writer.writeBinary(1, bytes2);
+        writer.complete();
+
+        assertThat(row.getBinary(0, bytes1.length)).isEqualTo(bytes1);
+        assertThat(row.getBinary(1, bytes2.length)).isEqualTo(bytes2);
+    }
+
+    @Test
+    public void testZeroOutPaddingString() {
+
+        Random random = new Random();
+        byte[] bytes = new byte[1024];
+
+        BinaryRowData row = new BinaryRowData(1);
+        BinaryRowWriter writer = new BinaryRowWriter(row);
+
+        writer.reset();
+        random.nextBytes(bytes);
+        writer.writeBinary(0, bytes);
+        writer.reset();
+        writer.writeString(0, BinaryString.fromString("wahahah"));
+        writer.complete();
+        int hash1 = row.hashCode();
+
+        writer.reset();
+        random.nextBytes(bytes);
+        writer.writeBinary(0, bytes);
+        writer.reset();
+        writer.writeString(0, BinaryString.fromString("wahahah"));
+        writer.complete();
+        int hash2 = row.hashCode();
+
+        assertThat(hash2).isEqualTo(hash1);
+    }
+
+    @Test
+    public void testTimestampData() {
+        // 1. compact
+        {
+            final int precision = 3;
+            BinaryRowData row = new BinaryRowData(2);
+            BinaryRowWriter writer = new BinaryRowWriter(row);
+            writer.writeTimestampNtz(0, TimestampNtz.fromMillis(123L), precision);
+            writer.setNullAt(1);
+            writer.complete();
+
+            assertThat(row.getTimestampNtz(0, 3).toString()).isEqualTo("1970-01-01T00:00:00.123");
+            assertThat(row.isNullAt(1)).isTrue();
+            row.setTimestampNtz(0, TimestampNtz.fromMillis(-123L), precision);
+            assertThat(row.getTimestampNtz(0, 3).toString()).isEqualTo("1969-12-31T23:59:59.877");
+        }
+
+        // 2. not compact
+        {
+            final int precision = 9;
+            TimestampLtz timestamp1 =
+                    TimestampLtz.fromLocalDateTime(
+                            LocalDateTime.of(1969, 1, 1, 0, 0, 0, 123456789));
+            TimestampLtz timestamp2 =
+                    TimestampLtz.fromLocalDateTime(
+                            LocalDateTime.of(1970, 1, 1, 0, 0, 0, 123456789));
+            BinaryRowData row = new BinaryRowData(2);
+            BinaryRowWriter writer = new BinaryRowWriter(row);
+            writer.writeTimestampLtz(0, timestamp1, precision);
+            writer.writeTimestampLtz(1, null, precision);
+            writer.complete();
+
+            // the size of row should be 8 + (8 + 8) * 2
+            // (8 bytes nullBits, 8 bytes fixed-length part and 8 bytes variable-length part for
+            // each timestamp(9))
+            assertThat(row.getSizeInBytes()).isEqualTo(40);
+
+            assertThat(row.getTimestampLtz(0, precision).toString())
+                    .isEqualTo("1969-01-01T00:00:00.123456789Z");
+            assertThat(row.isNullAt(1)).isTrue();
+            row.setTimestampLtz(0, timestamp2, precision);
+            assertThat(row.getTimestampLtz(0, precision).toString())
+                    .isEqualTo("1970-01-01T00:00:00.123456789Z");
+        }
+    }
+
+    @Test
+    public void testGetChar() {
+        BinaryRowData row = new BinaryRowData(3);
+        BinaryRowWriter writer = new BinaryRowWriter(row);
+
+        String shortString = "hello";
+        String longString = "This is a longer string for testing getChar method";
+        String unicodeString = "测试Unicode字符串";
+
+        writer.writeString(0, BinaryString.fromString(shortString));
+        writer.writeString(1, BinaryString.fromString(longString));
+        writer.writeString(2, BinaryString.fromString(unicodeString));
+        writer.complete();
+
+        // Test getChar with exact length
+        assertThat(row.getChar(0, shortString.length()).toString()).isEqualTo(shortString);
+        assertThat(row.getChar(1, longString.length()).toString()).isEqualTo(longString);
+        assertThat(row.getChar(2, unicodeString.length()).toString()).isEqualTo(unicodeString);
+
+        // Test getChar with different lengths (should still return the full string)
+        assertThat(row.getChar(0, shortString.length() + 10).toString()).isEqualTo(shortString);
+        assertThat(row.getChar(1, longString.length() - 10).toString()).isEqualTo(longString);
+
+        // Verify getChar returns same result as getString
+        assertThat(row.getChar(0, shortString.length())).isEqualTo(row.getString(0));
+        assertThat(row.getChar(1, longString.length())).isEqualTo(row.getString(1));
+        assertThat(row.getChar(2, unicodeString.length())).isEqualTo(row.getString(2));
+    }
+
+    @Test
+    public void testGetBytes() {
+        BinaryRowData row = new BinaryRowData(3);
+        BinaryRowWriter writer = new BinaryRowWriter(row);
+
+        byte[] smallBytes = new byte[] {1, 2, 3};
+        byte[] largeBytes = new byte[] {1, -1, 5, 10, -10, 127, -128, 0, 50, -50};
+        byte[] emptyBytes = new byte[0];
+
+        writer.writeBinary(0, smallBytes);
+        writer.writeBinary(1, largeBytes);
+        writer.writeBinary(2, emptyBytes);
+        writer.complete();
+
+        // Test getBytes method
+        assertThat(row.getBytes(0)).isEqualTo(smallBytes);
+        assertThat(row.getBytes(1)).isEqualTo(largeBytes);
+        assertThat(row.getBytes(2)).isEqualTo(emptyBytes);
+
+        // Verify getBytes returns same result as getBinary with correct length
+        assertThat(row.getBytes(0)).isEqualTo(row.getBinary(0, smallBytes.length));
+        assertThat(row.getBytes(1)).isEqualTo(row.getBinary(1, largeBytes.length));
+        assertThat(row.getBytes(2)).isEqualTo(row.getBinary(2, emptyBytes.length));
+
+        // Test with copied row
+        BinaryRowData copiedRow = row.copy();
+        assertThat(copiedRow.getBytes(0)).isEqualTo(smallBytes);
+        assertThat(copiedRow.getBytes(1)).isEqualTo(largeBytes);
+        assertThat(copiedRow.getBytes(2)).isEqualTo(emptyBytes);
+    }
+}
diff --git a/fluss-common/src/test/java/com/alibaba/fluss/row/BinarySegmentUtilsTest.java b/fluss-common/src/test/java/com/alibaba/fluss/row/BinarySegmentUtilsTest.java
index 76731f9f..08cdcef5 100644
--- a/fluss-common/src/test/java/com/alibaba/fluss/row/BinarySegmentUtilsTest.java
+++ b/fluss-common/src/test/java/com/alibaba/fluss/row/BinarySegmentUtilsTest.java
@@ -23,7 +23,7 @@ import org.junit.jupiter.api.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-/** Test for {@link com.alibaba.fluss.row.BinarySegmentUtils}. */
+/** Test for {@link BinarySegmentUtils}. */
 public class BinarySegmentUtilsTest {
 
     @Test
diff --git a/fluss-common/src/test/java/com/alibaba/fluss/row/DataFormatTestUtil.java b/fluss-common/src/test/java/com/alibaba/fluss/row/DataFormatTestUtil.java
new file mode 100644
index 00000000..01e2e72e
--- /dev/null
+++ b/fluss-common/src/test/java/com/alibaba/fluss/row/DataFormatTestUtil.java
@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.alibaba.fluss.row;
+
+import com.alibaba.fluss.memory.MemorySegment;
+import com.alibaba.fluss.types.DataType;
+import com.alibaba.fluss.types.RowType;
+
+import org.apache.paimon.utils.StringUtils;
+
+import java.util.Arrays;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** Utils for testing data formats. */
+public class DataFormatTestUtil {
+
+    /** Stringify the given {@link InternalRow}. */
+    public static String toStringNoRowKind(InternalRow row, RowType type) {
+        StringBuilder build = new StringBuilder();
+        for (int i = 0; i < type.getFieldCount(); i++) {
+            if (i != 0) {
+                build.append(", ");
+            }
+            if (row.isNullAt(i)) {
+                build.append("NULL");
+            } else {
+                InternalRow.FieldGetter fieldGetter =
+                        InternalRow.createFieldGetter(type.getTypeAt(i), i);
+                Object field = fieldGetter.getFieldOrNull(row);
+                if (field instanceof byte[]) {
+                    build.append(Arrays.toString((byte[]) field));
+                } else {
+                    build.append(field);
+                }
+            }
+        }
+        return build.toString();
+    }
+
+    /** Stringify the given {@link InternalRow} with ArrayType, RowType and MapType. */
+    public static String toStringWithRowKind(InternalRow row, RowType type) {
+        StringBuilder build = new StringBuilder();
+        for (int i = 0; i < type.getFieldCount(); i++) {
+            if (i != 0) {
+                build.append(", ");
+            }
+            if (row.isNullAt(i)) {
+                build.append("NULL");
+            } else {
+                InternalRow.FieldGetter fieldGetter =
+                        InternalRow.createFieldGetter(type.getTypeAt(i), i);
+                Object field = fieldGetter.getFieldOrNull(row);
+                build.append(getDataFieldString(field, type.getTypeAt(i)));
+            }
+        }
+        return build.toString();
+    }
+
+    /** Stringify the given field, including ArrayType, RowType and MapType. */
+    public static String getDataFieldString(Object field, DataType type) {
+        if (field instanceof byte[]) {
+            return Arrays.toString((byte[]) field);
+        } else if (field instanceof InternalRow) {
+            return String.format("(%s)", toStringWithRowKind((InternalRow) field, (RowType) type));
+        } else {
+            return field.toString();
+        }
+    }
+
+    /** Get a binary row of 24 bytes long. */
+    public static BinaryRowData get24BytesBinaryRow() {
+        // header (8 bytes) + 2 * string in fixed-length part (8 bytes each)
+        BinaryRowData row = new BinaryRowData(2);
+        BinaryRowWriter writer = new BinaryRowWriter(row);
+        writer.writeString(0, BinaryString.fromString(StringUtils.randomNumericString(2)));
+        writer.writeString(1, BinaryString.fromString(StringUtils.randomNumericString(2)));
+        writer.complete();
+        return row;
+    }
+
+    /** Get a binary row of 160 bytes long. */
+    public static BinaryRowData get160BytesBinaryRow() {
+        // header (8 bytes) +
+        // 72 byte length string (8 bytes in fixed-length, 72 bytes in variable-length) +
+        // 64 byte length string (8 bytes in fixed-length, 64 bytes in variable-length)
+        BinaryRowData row = new BinaryRowData(2);
+        BinaryRowWriter writer = new BinaryRowWriter(row);
+        writer.writeString(0, BinaryString.fromString(StringUtils.randomNumericString(72)));
+        writer.writeString(1, BinaryString.fromString(StringUtils.randomNumericString(64)));
+        writer.complete();
+        return row;
+    }
+
+    /**
+     * Get a binary row consisting of 6 segments. The bytes of the returned row is the same with the
+     * given input binary row.
+     */
+    public static BinaryRow getMultiSeg160BytesBinaryRow(BinaryRowData row160) {
+        BinaryRowData multiSegRow160 = new BinaryRowData(2);
+        MemorySegment[] segments = new MemorySegment[6];
+        int baseOffset = 8;
+        int posInSeg = baseOffset;
+        int remainSize = 160;
+        for (int i = 0; i < segments.length; i++) {
+            segments[i] = MemorySegment.wrap(new byte[32]);
+            int copy = Math.min(32 - posInSeg, remainSize);
+            row160.getSegments()[0].copyTo(160 - remainSize, segments[i], posInSeg, copy);
+            remainSize -= copy;
+            posInSeg = 0;
+        }
+        multiSegRow160.pointTo(segments, baseOffset, 160);
+        assertThat(multiSegRow160).isEqualTo(row160);
+        return multiSegRow160;
+    }
+
+    /**
+     * Get a binary row consisting of 2 segments. Its first segment is the same with the given input
+     * binary row, while its second segment is empty.
+     */
+    public static BinaryRow getMultiSeg160BytesInOneSegRow(BinaryRowData row160) {
+        MemorySegment[] segments = new MemorySegment[2];
+        segments[0] = row160.getSegments()[0];
+        segments[1] = MemorySegment.wrap(new byte[row160.getSegments()[0].size()]);
+        row160.pointTo(segments, 0, row160.getSizeInBytes());
+        return row160;
+    }
+
+    /** Split the given byte array into two memory segments. */
+    public static MemorySegment[] splitBytes(byte[] bytes, int baseOffset) {
+        int newSize = (bytes.length + 1) / 2 + baseOffset;
+        MemorySegment[] ret = new MemorySegment[2];
+        ret[0] = MemorySegment.wrap(new byte[newSize]);
+        ret[1] = MemorySegment.wrap(new byte[newSize]);
+
+        ret[0].put(baseOffset, bytes, 0, newSize - baseOffset);
+        ret[1].put(0, bytes, newSize - baseOffset, bytes.length - (newSize - baseOffset));
+        return ret;
+    }
+
+    /** A simple class for testing generic type getting / setting on data formats. */
+    public static class MyObj {
+        public int i;
+        public double j;
+
+        public MyObj(int i, double j) {
+            this.i = i;
+            this.j = j;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) {
+                return true;
+            }
+            if (o == null || getClass() != o.getClass()) {
+                return false;
+            }
+
+            MyObj myObj = (MyObj) o;
+
+            return i == myObj.i && Double.compare(myObj.j, j) == 0;
+        }
+
+        @Override
+        public String toString() {
+            return "MyObj{" + "i=" + i + ", j=" + j + '}';
+        }
+    }
+}
diff --git a/fluss-common/src/test/java/com/alibaba/fluss/testutils/DataTestUtils.java b/fluss-common/src/test/java/com/alibaba/fluss/testutils/DataTestUtils.java
index 736f6b0f..7c9ec32d 100644
--- a/fluss-common/src/test/java/com/alibaba/fluss/testutils/DataTestUtils.java
+++ b/fluss-common/src/test/java/com/alibaba/fluss/testutils/DataTestUtils.java
@@ -528,7 +528,7 @@ public class DataTestUtils {
 
             ((DefaultLogRecordBatch) memoryLogRecords.batches().iterator().next())
                     .setCommitTimestamp(maxTimestamp);
-            memoryLogRecords.ensureValid(CURRENT_LOG_MAGIC_VALUE);
+            memoryLogRecords.ensureValid(magic);
             return memoryLogRecords;
         }
     }
-- 
2.33.0

